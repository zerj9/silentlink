use crate::config::AppState;
use crate::error::ApiError;
use crate::utils::create_id;
use axum::{extract::State, Json};
use serde::Deserialize;
use sqlx::postgres::types::Oid;
use sqlx::postgres::Postgres;
use sqlx::{Row, Transaction};
use tracing::info;
use validator::Validate;

#[derive(Debug, Validate, Deserialize)]
pub struct CreateGraphRequest {
    name: String,
    description: Option<String>,
}

pub async fn create_graph(
    State(state): State<AppState>,
    Json(request): Json<CreateGraphRequest>,
) -> Result<Json<serde_json::Value>, ApiError> {
    request.validate()?;

    info!("Creating graph with name: {}", request.name);
    // Start a transaction
    let mut transaction: Transaction<Postgres> = state.pool.begin().await?;

    // Generate random graph name for AGE as they are not unique in the database
    // Must be unique in the application
    // This is the name that will be used to create the graph in AGE
    // Must start with a letter (Regex in AGE repo)
    let app_graphid = format!("g{}", create_id(6));

    // TODO: Check if graph with the same name already exists

    // Create the graph in AGE
    let age_query = "SELECT ag_catalog.create_graph($1)";
    sqlx::query(age_query)
        .bind(&app_graphid)
        .execute(&mut *transaction)
        .await?;

    // Get the graphid generated by AGE to link with the graph_info table
    let graph_id_query = "SELECT graphid FROM ag_catalog.ag_graph WHERE name = $1";
    let graph_id_query_response = sqlx::query(graph_id_query)
        .bind(&app_graphid)
        .fetch_one(&mut *transaction)
        .await?;
    let age_graph_id: Oid = graph_id_query_response.get("graphid");
    let age_graph_id: i64 = age_graph_id.0.into();

    // Insert the graph info into the graph_info table
    let graph_info_query =
        "INSERT INTO app_data.graph_info (app_graphid, age_graphid, name, description) VALUES ($1, $2, $3, $4)";
    sqlx::query(&graph_info_query)
        .bind(&app_graphid)
        .bind(&age_graph_id)
        .bind(&request.name)
        .bind(&request.description)
        .execute(&mut *transaction)
        .await?;

    // Commit the transaction
    transaction.commit().await?;

    Ok(Json(serde_json::json!({})))
}
